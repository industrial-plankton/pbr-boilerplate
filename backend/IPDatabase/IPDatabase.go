package IPDatabase

import (
	"backend/utility"
	"fmt"
	"strconv"
	"strings"
	"time"

	"github.com/jmoiron/sqlx"
	"github.com/vishalkuo/bimap"
)

func timeTrack(start time.Time, name string) {
	elapsed := time.Since(start)
	fmt.Println(name, " took ", elapsed)
}

func GetUnits(mysqlDB *sqlx.DB) {
	// defer timeTrack(time.Now(), "Unit")
	// fetch all places from the db
	var values [][]string
	rows, _ := mysqlDB.Query("SELECT `parts`.`index_Parts`, `unit`.`unit`, `parts`.`IP SKU` FROM `demodb`.`parts` `parts`, `demodb`.`unit` `unit` WHERE `parts`.`units` = `unit`.`index_unit` ORDER BY `parts`.`index_Parts`")

	// iterate over each row
	for rows.Next() {
		var units string
		var index_Parts int
		var SKU string

		// note that city can be NULL, so we use the NullString type
		_ = rows.Scan(&index_Parts, &units, &SKU)
		rowdata := []string{units, SKU, strconv.Itoa(index_Parts)}
		values = append(values, rowdata)
	}
	sliceofslices := values[:]
	fmt.Println(sliceofslices, "\n")
}

func GetHeaders(mysqlDB *sqlx.DB, table string) []interface{} { //returns headers of the table
	// defer timeTrack(time.Now(), "Get Headers of "+table)
	// fetch all places from the db
	var headers []interface{}
	SQL := "SELECT * FROM information_schema.columns WHERE table_schema = 'public' AND table_name='" + table + "';"
	rows, err := mysqlDB.Queryx(SQL)
	if err != nil {
		utility.Log(err)
		return headers
	}
	// iterate over each row
	for rows.Next() {
		rowdata, _ := rows.SliceScan()
		headers = append(headers, rowdata[3]) //column names are stored in column 4 of information_schema.columns
	}
	// utility.Log("Headers found: ")
	// utility.Log(headers)
	return headers
}

func GetView(mysqlDB *sqlx.DB, view string /*, headers []interface{}*/) [][]interface{} { //returns entire view
	defer timeTrack(time.Now(), "View "+view)
	SQL := "SELECT * FROM " + view
	values, _ := headerQuery(mysqlDB, SQL, view)
	// fetch all places from the db
	// var values [][]interface{}
	// values = append(values, headers)
	// rows, err := mysqlDB.Queryx("SELECT * FROM " + view)
	// if err != nil {
	// 	fmt.Println(err)
	// 	return values
	// }
	// // iterate over each row
	// for rows.Next() {
	// 	rowdata, _ := rows.SliceScan()
	// 	values = append(values, rowdata)
	// }

	return values
}

func Search(mysqlDB *sqlx.DB, table, key, keycolumn string) [][]interface{} {
	defer timeTrack(time.Now(), "Search for "+key)
	// var values [][]interface{}
	SQL := "SELECT * FROM " + table + " t WHERE t." + keycolumn + "::text='" + key + "'::text"
	values, _ := standQuery(mysqlDB, SQL)
	// rows, err := mysqlDB.Queryx("SELECT * FROM " + table + " t WHERE t." + keycolumn + "::text='" + key + "'::text")
	// if err != nil {
	// 	fmt.Println(err)
	// 	return values
	// }

	// for rows.Next() {
	// 	rowdata, _ := rows.SliceScan()
	// 	values = append(values, rowdata)
	// }

	return values
}

func MultiLIKE(mysqlDB *sqlx.DB, table string, keys []string, keycolumns []string, combiners []string) [][]interface{} {
	//KeyColumns should be appended with ::text when relevent
	//Keys should be in the form 'key', '%key%' or '_key_', _ is single wildcard, % is multi wildcard
	defer timeTrack(time.Now(), "MultiSearch")
	// var values [][]interface{}
	conditions := "("
	for i, e := range keycolumns {
		conditions = conditions + combiners[i] + " LOWER(" + e + ") ~~ LOWER(" + keys[i] + ")"
	}
	conditions = conditions + ")"
	fmt.Print(conditions)
	SQL := "SELECT * FROM " + table + " AS t WHERE" + conditions
	values, _ := standQuery(mysqlDB, SQL)
	// rows, err := mysqlDB.Queryx("SELECT * FROM " + table + " AS t WHERE" + conditions)
	// if err != nil {
	// 	fmt.Println(err)
	// 	return values
	// }

	// for rows.Next() {
	// 	rowdata, _ := rows.SliceScan()
	// 	values = append(values, rowdata)
	// }

	return values
}

func AddWildCards(array []string) []string { //adds % before and after each string and replaces spaces with %
	for i, e := range array {
		array[i] = "'%" + strings.ReplaceAll(e, " ", "%") + "%'"
	}
	return array
}

func Insert(mysqlDB *sqlx.DB, table string, columns []interface{}, data [][]interface{}) {
	defer timeTrack(time.Now(), "Insert to "+table)
	primarykey := getPrimaryKeyColumnName(mysqlDB, table)
	for i := range columns { //Cut out primary Key index, it should be autogenerated
		if columns[i] == primarykey {
			columns = append(columns[:i], columns[i+1:]...)
			for d := range data {
				data[d] = append(data[d][:i], data[d][i+1:]...)
			}
			break
		}
	}
	combinedColumns, combinedValues := formatParams(columns, data)
	SQL := "INSERT INTO " +
		table +
		" (" + combinedColumns +
		") VALUES (" +
		combinedValues +
		");"
	fmt.Print("Insert SQL:" + SQL)
	standExec(mysqlDB, SQL)
}

func Update(mysqlDB *sqlx.DB, table string, primarykey string, columns []interface{}, data []interface{}) {
	defer timeTrack(time.Now(), "Update of "+table)
	setString := ""
	// data = FormatDataTypes(mysqlDB, table, columns, data)[0]
	data = utility.ParseNulls([][]interface{}{data})[0]
	for i := range columns {
		setString += fmt.Sprint(columns[i]) + "=" + fmt.Sprint(data[i]) + ", "
	}
	setString = strings.TrimSuffix(setString, ", ")
	SQL := "UPDATE " + table + " SET " + setString +
		" WHERE " + getPrimaryKeyColumnName(mysqlDB, table) + "=" + primarykey
	fmt.Print("Modify SQL:" + SQL)
	standExec(mysqlDB, SQL)
}

func Convert(mysqlDB *sqlx.DB, table string, key string, keycolumn string, endcolumn string) []interface{} {
	defer timeTrack(time.Now(), "Convert "+key+" to "+endcolumn)
	// var value []interface{}

	SQL := "SELECT t." + endcolumn + " FROM " + table + " t WHERE t." + keycolumn + "::text='" + key + "'::text"

	value, _ := standQuery(mysqlDB, SQL)
	if value == nil {
		return nil
	}

	return value[0]
}

func Exists(mysqlDB *sqlx.DB, table string, key string, keycolumn string) bool { //checks if key exists in keycolumn, returns false immidiately if no key
	defer timeTrack(time.Now(), "Exist check of "+key+" in "+table+"."+keycolumn)
	if key == "" {
		return false
	}
	var exists bool
	SQL := "select exists(select 1 from " + table + " where " + keycolumn + "=" + key + ")"
	rows, err := mysqlDB.Queryx(SQL)
	if err != nil {
		utility.Log(SQL + " Failed")
		utility.Log(err)
		return exists
	}
	for rows.Next() {
		err = rows.Scan(&exists)
	}
	if err != nil {
		fmt.Println(err)
	}
	return exists
}

func formatParams(columns []interface{}, data [][]interface{}) (string, string) { //arranges columns and data for Inserting
	combinedColumns := ""
	for _, e := range columns {
		combinedColumns = combinedColumns + fmt.Sprintf("%v", e) + ", "
	}
	combinedColumns = strings.TrimRight(combinedColumns, ", ")
	data = utility.ParseNulls(data)
	combinedValues := ""
	for _, rowData := range data {
		for _, val := range rowData {
			combinedValues = combinedValues + fmt.Sprintf("%v", val) + ", "
		}
		combinedValues = strings.TrimRight(combinedValues, ", ") + "),("
	}
	combinedValues = strings.TrimRight(combinedValues, "),(")

	return combinedColumns, combinedValues
}

func getPrimaryKeyColumnName(mysqlDB *sqlx.DB, table string) string {
	defer timeTrack(time.Now(), "Get Primary Key name of "+table)

	SQL := "SELECT c.column_name " +
		"FROM information_schema.key_column_usage AS c " +
		"LEFT JOIN information_schema.table_constraints AS t " +
		"ON t.constraint_name = c.constraint_name " +
		"WHERE t.table_name = '" + table + "' AND t.constraint_type = 'PRIMARY KEY';"

	primarykey, _ := standQuery(mysqlDB, SQL)
	return fmt.Sprintf("%v", primarykey[0][0])
}

func standQuery(mysqlDB *sqlx.DB, SQL string) ([][]interface{}, error) {
	var values [][]interface{}
	rows, err := mysqlDB.Queryx(SQL)
	if err != nil {
		utility.Log(SQL + " Failed")
		utility.Log(err)
		// fmt.Println(err)
		return values, err
	}

	for rows.Next() {
		rowdata, _ := rows.SliceScan()
		values = append(values, rowdata)
	}
	return values, nil
}

func headerQuery(mysqlDB *sqlx.DB, SQL, table string) ([][]interface{}, error) { //must be selecting all columns in normal order
	var values [][]interface{}

	values = append(values, GetHeaders(mysqlDB, table))
	rows, err := mysqlDB.Queryx(SQL)
	if err != nil {
		utility.Log(SQL + " Failed")
		utility.Log(err)
		// fmt.Println(err)
		return values, err
	}

	for rows.Next() {
		rowdata, _ := rows.SliceScan()
		values = append(values, rowdata)
	}
	return values, nil
}

func standExec(mysqlDB *sqlx.DB, SQL string) error {
	tx := mysqlDB.MustBegin()
	tx.MustExec(SQL)
	err := tx.Commit()
	if err != nil {
		utility.Log(SQL + " FAILED")
		utility.Log(err)
		// fmt.Print(err)
	}
	return err
}

func TranslateIndexs(mysqlDB *sqlx.DB, translationTables []string, columns []interface{}, keycolumn interface{}, headerMap *bimap.BiMap, data [][]interface{}) [][]interface{} {
	maps := make([]*bimap.BiMap, len(translationTables))
	datalocations := make([]int, len(translationTables))
	for i := range maps {
		maps[i] = utility.BuildMap(GetView(mysqlDB, translationTables[i]), []int{0}) // build translation maps //if index column not furthest right will need to relogic this
	}

	for i, e := range columns { //go through columns and save index locations, convert keycolumn to non-index header
		for m := range datalocations {
			if columns[i] == translationTables[m]+"_index" {
				datalocations[m] = i
				continue
			}
		}
		if e == keycolumn {
			columns[i], _ = headerMap.GetInverse(keycolumn)
		}
	}
	for i := range data { //translate index parts back to index value
		for d := range datalocations {
			data[i][datalocations[d]], _ = maps[d].Get(data[i][datalocations[d]])
		}
	}
	return data
}

func UpdateOrAdd(mysqlDB *sqlx.DB, table string, headerMap *bimap.BiMap, data [][]interface{}, headerValues []interface{}) {
	columns := utility.RearrangeHeaders(headerMap, headerValues) //relabel the sheet headers to the databse headers, in order of sheet
	keycolumnLoc := utility.FindUnIndexedLocation(table, columns)
	var keycolumn interface{}
	if keycolumnLoc == -1 {
		keycolumn = nil //if table doesnt have a keycolumn -> nil
	} else {
		keycolumn = columns[keycolumnLoc]
	}
	indexLoc := utility.FindPrimIndexLocation(columns)
	translationTables := utility.FindTranslationTables(table, columns)
	utility.Log(keycolumn)
	utility.Log(indexLoc)
	utility.Log(translationTables)
	if len(translationTables) > 0 { //only translate if needed
		data = TranslateIndexs(mysqlDB, translationTables, columns, keycolumn, headerMap, data)
	} else {
		for i := range columns { //go through columns and convert keycolumn to non-index header
			if columns[i] == keycolumn {
				columns[i], _ = headerMap.GetInverse(keycolumn)
			}
		}
	}

	for _, row := range data { //go through each line
		primaryIndex := fmt.Sprint(row[indexLoc]) //grab index_parts from the collected data

		if Exists(mysqlDB, table, primaryIndex, fmt.Sprint(columns[indexLoc])) { //check that the index exists
			Update(mysqlDB, table, primaryIndex, columns, row)
		} else {
			Insert(mysqlDB, table, columns, data)
		}
	}
}
